import * as ipfs from "ipfs";
/** Declaration file generated by dts-gen */
import {EventEmitter} from 'events';
export as namespace orbit_db;
export = OrbitDB;


declare class OrbitDB {
    id: string;
    _ipfs: ipfs;
    key: string;
    keystore: any;

    constructor(ipfs:ipfs, directory?: string, options?:any);

    counter(...args: any[]): void;

    create(...args: any[]): void;

    disconnect(...args: any[]): void;

    docs(...args: any[]): void;

    docstore(...args: any[]): void;

    eventlog(...args: any[]): OrbitDB.Eventstore;

    feed(...args: any[]): void;

    keyvalue(...args: any[]): void;

    kvstore(...args: any[]): void;

    log(...args: any[]): void;

    open(...args: any[]): void;

    stop(...args: any[]): void;

    static addDatabaseType(...args: any[]): void;

    static databaseTypes: string[];

    static getDatabaseTypes(...args: any[]): void;

    static isValidType(...args: any[]): void;

}

declare namespace OrbitDB {
  namespace Log {
    type entry<T> = {
      hash: string, // "Qm...Foo", we'll set the hash after persisting the entry
      id: number, // For determining a unique chain
      payload: T, // Can be any JSON.stringifyable data
      next: any[], // Array of Multihashes
      v: 0, // For future data structure updates, should currently always be 0
      clock: any,

    }
  }
  type address = { root:string, path:string}
  class Store {
      all: any[];
      type: string;
      address: address;
      key: any;
      events: EventEmitter;
      
      load(amount?: number):Promise<Store>;
      close():Promise<any>;
      drop():Promise<any>;
      saveSnapshot(): Promise<any>;
      loadFromSnapshot(hash:string, callback:(x:any)=>any):Promise<Store>;
  }

  
  class Eventstore extends Store {
    add(item: any): void;
    get(item: any): any;
    iterator(options?: any): Iterator<any> & { collect: () => any[] };

  } 
  // Mapping for 'database type' -> Class
  // type databaseTypes = {
  //   'counter': CounterStore,
  //   'eventlog': EventStore,
  //   'feed': FeedStore,
  //   'docstore': DocumentStore,
  //   'keyvalue': KeyValueStore,
  // }
    // namespace prototype {
    //     function counter(...args: any[]): void;
    //
    //     function create(...args: any[]): void;
    //
    //     function disconnect(...args: any[]): void;
    //
    //     function docs(...args: any[]): void;
    //
    //     function docstore(...args: any[]): void;
    //
    //     function eventlog(...args: any[]): void;
    //
    //     function feed(...args: any[]): void;
    //
    //     function keyvalue(...args: any[]): void;
    //
    //     function kvstore(...args: any[]): void;
    //
    //     function log(...args: any[]): void;
    //
    //     function open(...args: any[]): void;
    //
    //     function stop(...args: any[]): void;
    //
    // }

}
